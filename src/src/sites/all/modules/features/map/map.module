<?php
/**
 * @file
 * Code for the Map feature.
 */


/**
 * Implements hook_menu().
 */
function map_menu() {
  // A menu callback is required when using ajax outside of the Form API.
  $items['map_filter_block_ajax_callback'] = array(
    'page callback' => 'map_filter_block_ajax_response',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'map_ajax.inc',
  );
  return $items;
}
/**
 * Implements hook_views_ajax_data_alter().
 */
//function map_views_ajax_data_alter(&$commands, $view) {
  // alter data returned by locations feed on ajax requests
//}

/**
 * Implements hook_block_info().
 */
function map_block_info() {
  // Many options are defined in hook_block_info():
  $blocks['map_filter_block'] = array(
    // info: The name of the block.
    'info' => t('Map filter block'),
    // Block caching options (per role, per user, etc.)
    // DRUPAL_CACHE_PER_ROLE is the default.
    // @todo set to DRUPAL_CACHE_PER_PAGE or DRUPAL_CACHE_GLOBAL when finished implementing
    'cache' => DRUPAL_NO_CACHE,

    // This sample shows how to provide default settings. In this case we'll
    // enable the block in the first sidebar and make it visible only on
    // 'node/*' pages. See the hook_block_info() documentation for these.
    'status' => TRUE,
    'region' => 'sidebar_first',
    'visibility' => BLOCK_VISIBILITY_LISTED,
    'pages' => '<front>',
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 *
 * This hook generates the contents of the blocks themselves.
 */
function map_block_view($delta = '') {
  // The $delta parameter tells us which block is being requested.
  switch ($delta) {
    case 'map_filter_block':
      $block['subject'] = t('Map filter block');
      $block['content'] = map_block_contents($delta);
      drupal_add_js(drupal_get_path('module', 'map') . '/js/jquery.treeselect.min.js', 'file');
      drupal_add_js(drupal_get_path('module', 'map') . '/js/map.js', array('type' => 'file', 'scope' => 'footer', 'weight' => 99));
      drupal_add_css(drupal_get_path('module', 'map') . '/js/jquery.treeselect.css', array('type' => 'file', 'scope' => 'header', 'weight' => 99));
      break;
  }
  return $block;
}

function map_block_contents($which_block) {
  switch ($which_block) {
    case 'map_filter_block':
      // Modules would typically perform some database queries to fetch the
      // content for their blocks. Here, we'll just use the variable set in the
      // block configuration or, if none has set, a default value.
      // Block content can be returned in two formats: renderable arrays
      // (as here) are preferred though a simple string will work as well.
      // Block content created through the UI defaults to a string.

      // drupal_add_library is invoked automatically when a form element has the
      // '#ajax' property, but since we are not rendering a form here, we have to
      // do it ourselves.
      drupal_add_library('system', 'drupal.ajax');
      // The use-ajax class is special, so that the link will call without causing
      // a page reload. Note the /nojs portion of the path - if javascript is
      // enabled, this part will be stripped from the path before it is called.
      $link = l(t('Ajax'), 'map_filter_block_ajax_callback/nojs/', array('attributes' => array('class' => array('use-ajax'))));
      $filters = taxonomy_get_tree('2', 0, 3);
      $link2 = l(t('JS'), '#', array('attributes' => array('class' => array('refresh-map'))));

      $output = "<div id='test-div'><ul><li>$link</li><li>$link2</li></ul></div>";
      $output .= "<div id='chosentree'></div>";
      //$output .= '<ul id="filters">';
      $tree = _map_taxonomy_build_tree($filters);
      $rendered_tree = _map_taxonomy_tree_render($tree);
      $output .= drupal_render($rendered_tree);
      $result = array(
        '#markup' => $output,
      );
      return $result;
  }
}

/*
 * Helper function to render nested tree to ul with wrapping div
 * from https://api.drupal.org/comment/52303#comment-52303
 */
function _map_taxonomy_tree_render($tree, $recurring = FALSE) {
  $items = array();
  if (count($tree)) {
    foreach ($tree as $term) {
      //$path = taxonomy_term_uri($term);
      $attributes = array('class' => array('filter-item ' . $term->name), 'id' => array('tid-'. $term->tid) );
      $item = array('data' => l($term->name, '', array('attributes' => $attributes)));

      if (isset($term->children)) {
        $item["children"] = _map_taxonomy_tree_render($term->children, TRUE);
      }
      $items[] = $item;
    }
  }
  if ($recurring) {
    return $items;
  }
  return array(
    '#theme' => 'item_list',
    '#items' => $items,
    '#attributes' => array('class' => 'filter-tree' , 'id' => 'filters'),
  );
}

/*
 * Helper function to build nested tree
 * from https://api.drupal.org/comment/52303#comment-52303
 */
function _map_taxonomy_build_tree($flatTree){
  $tree = array();
  $last_term_stack = array();
  foreach ($flatTree as &$term) {
    while(count($last_term_stack) > 0){
      if(in_array(end($last_term_stack)->tid, $term->parents)) {
        $lastTerm = end($last_term_stack);
        $lastTerm->children[]=$term;
        array_push($last_term_stack,$term);
        break;
      } else {
        array_pop($last_term_stack);
      }
    }
    if(empty($last_term_stack)){
      $tree[] =$term;
      array_push($last_term_stack, $term);
    }
  }
  return $tree;
}